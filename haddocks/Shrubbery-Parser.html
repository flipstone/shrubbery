<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Shrubbery.Parser</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">shrubbery-0.1.0.0</span><ul class="links" id="page-menu"><li><a href="src/Shrubbery.Parser.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Shrubbery.Parser</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides facilities for parsing input values into sum types
  that implement the <code><a href="Shrubbery-Classes.html#t:Unification" title="Shrubbery.Classes">Unification</a></code> type classes. A <code><a href="Shrubbery-Parser.html#t:Parser" title="Shrubbery.Parser">Parser</a></code> is constructed
  by giving a handler for each type in the union that attempts to parse the
  input value into that type. These handlers must be given in the same order
  as the types in the type-list that describes the sum type.</p><p>For instance:</p><pre> parser :: Parser Maybe String [Int, Bool, String]
 parser =
     parseOption (readMaybe :: String -&gt; Maybe Int)
   $ parseOption (readMaybe :: String -&gt; Maybe Bool)
   $ parseOption (Just :: Strng -&gt; Maybe String)
   $ parseEnd
 </pre><p>Or, if you prefer to use <code>TypeApplications</code>,</p><pre> parser :: Parser Maybe String [Int, Bool, String]
 parser =
     parseOption @Int readMaybe
   $ parseOption @Bool readMaybe
   $ parseOption @String Just
   $ parseEnd
 </pre><p>When a <code><a href="Shrubbery-Parser.html#t:Parser" title="Shrubbery.Parser">Parser</a></code> is run via <code><a href="Shrubbery-Parser.html#v:parse" title="Shrubbery.Parser">parse</a></code>, it returns the parsing results for
  all the options, allowing the caller to choose how to handle them. For
  instance, using the parser above one might write the following code to
  pick the first successful option from the list:</p><pre> case catMaybes (parse parser someInputString) of
   (first:_) -&gt;
     Just first

   [] -&gt;
     Nothing
 </pre></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Parser">Parser</a> f input (types :: [<a href="../base-4.14.1.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a>])</li><li class="src short"><a href="#v:parse">parse</a> :: (<a href="Shrubbery-Classes.html#t:Unification" title="Shrubbery.Classes">Unification</a> sum, <a href="../base-4.14.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f) =&gt; <a href="Shrubbery-Parser.html#t:Parser" title="Shrubbery.Parser">Parser</a> f input (<a href="Shrubbery-Classes.html#t:BranchTypes" title="Shrubbery.Classes">BranchTypes</a> sum) -&gt; input -&gt; [f sum]</li><li class="src short"><a href="#v:parseOption">parseOption</a> :: <span class="keyword">forall</span> a f input rest. (input -&gt; f a) -&gt; <a href="Shrubbery-Parser.html#t:Parser" title="Shrubbery.Parser">Parser</a> f input rest -&gt; <a href="Shrubbery-Parser.html#t:Parser" title="Shrubbery.Parser">Parser</a> f input (a ': rest)</li><li class="src short"><a href="#v:parseEnd">parseEnd</a> :: <a href="Shrubbery-Parser.html#t:Parser" title="Shrubbery.Parser">Parser</a> f input '[]</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Parser" class="def">Parser</a> f input (types :: [<a href="../base-4.14.1.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a>]) <a href="src/Shrubbery.Parser.html#Parser" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></p><div class="doc"><p>A <code><a href="Shrubbery-Parser.html#t:Parser" title="Shrubbery.Parser">Parser</a></code> allows an input value to be examined to see whether one or more
  underlying types can be constructed from it, which are then embedded in a
  union. The resulting type can be any type that provides an instance of
  <code><a href="Shrubbery-Classes.html#t:Unification" title="Shrubbery.Classes">Unification</a></code>, such as <code><a href="Shrubby-Union.html#v:Union" title="Shrubby.Union">Union</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:parse" class="def">parse</a> :: (<a href="Shrubbery-Classes.html#t:Unification" title="Shrubbery.Classes">Unification</a> sum, <a href="../base-4.14.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f) =&gt; <a href="Shrubbery-Parser.html#t:Parser" title="Shrubbery.Parser">Parser</a> f input (<a href="Shrubbery-Classes.html#t:BranchTypes" title="Shrubbery.Classes">BranchTypes</a> sum) -&gt; input -&gt; [f sum] <a href="src/Shrubbery.Parser.html#parse" class="link">Source</a> <a href="#v:parse" class="selflink">#</a></p><div class="doc"><p>Executes a <code><a href="Shrubbery-Parser.html#t:Parser" title="Shrubbery.Parser">Parser</a></code> with a given input value, producing the list of options
  returned be each function given to <code><a href="Shrubbery-Parser.html#v:parseOption" title="Shrubbery.Parser">parseOption</a></code>. The returned list will
  always have a number of items equal to the number of options added to the
  <code><a href="Shrubbery-Parser.html#t:Parser" title="Shrubbery.Parser">Parser</a></code>.</p><p>The caller must decide how to choose one or more results from the list
  of options however is desired.</p></div></div><div class="top"><p class="src"><a id="v:parseOption" class="def">parseOption</a> :: <span class="keyword">forall</span> a f input rest. (input -&gt; f a) -&gt; <a href="Shrubbery-Parser.html#t:Parser" title="Shrubbery.Parser">Parser</a> f input rest -&gt; <a href="Shrubbery-Parser.html#t:Parser" title="Shrubbery.Parser">Parser</a> f input (a ': rest) <a href="src/Shrubbery.Parser.html#parseOption" class="link">Source</a> <a href="#v:parseOption" class="selflink">#</a></p><div class="doc"><p>Adds an option to the <code><a href="Shrubbery-Parser.html#t:Parser" title="Shrubbery.Parser">Parser</a></code>. Every option in the <code><a href="Shrubbery-Parser.html#t:Parser" title="Shrubbery.Parser">Parser</a></code> will be
  given a chance to examine the input and possibly produce a value of the type
  it produces. IF the option cannot produce a value its type from the input, it
  should return whatever the appropriate value for functor <code>f</code> is. For example,
  if <code><a href="../base-4.14.1.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> is used as <code>f</code>, the function would produce <code>Nothing</code> when given
  input it does not want to handle.</p><p>Any values <code>a</code> that are produced by the function will be unified with the
  other values according the <code><a href="Shrubbery-Classes.html#t:Unification" title="Shrubbery.Classes">Unification</a></code> sum type that is expected when
  <code><a href="Shrubbery-Parser.html#v:parse" title="Shrubbery.Parser">parse</a></code> is used.</p></div></div><div class="top"><p class="src"><a id="v:parseEnd" class="def">parseEnd</a> :: <a href="Shrubbery-Parser.html#t:Parser" title="Shrubbery.Parser">Parser</a> f input '[] <a href="src/Shrubbery.Parser.html#parseEnd" class="link">Source</a> <a href="#v:parseEnd" class="selflink">#</a></p><div class="doc"><p>Represents the base case of where no parsing options are present. You can
  use this as the second argument to <code><a href="Shrubbery-Parser.html#v:parseOption" title="Shrubbery.Parser">parseOption</a></code> when have no other options
  to specify.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.0</p></div></body></html>