-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/flipstone/shrubbery#readme</a>
@package shrubbery
@version 0.1.0.0


-- | This module provides type families that are useful for working with
--   type-level lists. Usually you won't need to use these types directly
--   as while using this package, but they may occasionally come in useful
--   if you find yourself writing your own helper functions.
module Shrubbery.TypeList

-- | This type finds the first index of a type in the given list as a
--   type-level natural. It is implemented as a type synonym around
--   <a>FirstIndexOfWithMsg</a> to provide a nice error message when the
--   given type is not found in the list.
type FirstIndexOf t types = FirstIndexOfWithMsg t types (NotAMemberMsg t types)

-- | Finds the first index of a type in the given list as a type-level
--   natural.
--   
--   The last argument of the type family is the error message that will be
--   given if the type is not found. Normally you will just use the
--   <a>FirstIndexOf</a> synonym, but you can use this instead if you want
--   to provide a customized error message.
type family FirstIndexOfWithMsg t (types :: [Type]) (errMsg :: ErrorMessage)

-- | This type finds the type at the given index in a list of types. It is
--   implemented as a type synonym around <a>TypeAtIndexWithMsg</a> to
--   provide a nice error message when the given type is not found in the
--   list.
type TypeAtIndex n types = TypeAtIndexWithMsg n types (OutOfBoundsMsg n types)

-- | Finds the type at the given index in a list of types.
--   
--   The last argument of the type family is the error message that will be
--   given if the type is not found. Normally you will just use the
--   <a>TypeAtIndex</a> synonym, but you can use this instead if you want
--   to provide a customized error message.
type family TypeAtIndexWithMsg (n :: Nat) (types :: [Type]) (errMsg :: ErrorMessage)

-- | Similar to <a>KnownNat</a>, this class allows length of a type list
--   that is known at compile time to be retrieved at runtime. This
--   functionality is exported as a class rather than a family both to
--   simplify the type signatures of functions that use this knowledge and
--   for situations where consumers would need to turn on
--   <tt>UndecidableInstances</tt> to use it.
class KnownLength (types :: [Type])
lengthOfTypes :: KnownLength types => proxy types -> Int

-- | This is the default error message used by <a>FirstIndexOf</a> when the
--   type is not found.
type NotAMemberMsg t (types :: [Type]) = ('ShowType t :<>: 'Text " is not a member of " :<>: 'ShowType types)

-- | This is the default error message used by <a>TypeAtIndex</a> when the
--   index is out of bounds.
type OutOfBoundsMsg (index :: Nat) (types :: [Type]) = ('Text "Index " :<>: 'ShowType index :<>: 'Text " is out of bounds for the type list of length " :<>: 'ShowType (Length types) :<>: 'Text ": " :<>: 'ShowType types)

-- | Used by <a>KnownLength</a> to calculate the length of a type-level
--   list.
type family Length (types :: [Type]) :: Nat

type family ZippedTypes front focus back :: [Type]
instance (GHC.TypeNats.KnownNat length, length GHC.Types.~ Shrubbery.TypeList.Length types) => Shrubbery.TypeList.KnownLength types


-- | This module provides types and functions for finding and using the
--   index of a type within a type-level list.
module Shrubbery.BranchIndex

-- | A <a>BranchIndex</a> is an zero-based index into a list of types for
--   which the type at the index is known. This type is used with
--   <a>Branches</a> to perform efficient branching at runtime.
data BranchIndex t (types :: [Type])

-- | Finds the first index of a type in a list of types. The type list and
--   the type being searched for must be inferrable based on the usage, or
--   be supplied via <tt>TypeApplications</tt>.
firstIndexOfType :: (KnownNat branchIndex, branchIndex ~ FirstIndexOf t types) => BranchIndex t types

-- | Builds an index based on an known index value from the type system,
--   associating it with the appropriate type from the list. The index is
--   specified via a proxy value.
indexOfTypeAt :: (KnownNat branchIndex, t ~ TypeAtIndex branchIndex types) => proxy branchIndex -> BranchIndex t types

-- | Retrieves the <a>Int</a> representation of the branch index. It it up
--   to the caller to use this integer in a responsible fashion ;)
branchIndexToInt :: BranchIndex t types -> Int

-- | <a>TypeZipper</a> facilitates interating through a list of known types
--   while keeping track of the index as you go. You might need this if
--   you're keeping track of a list of operations that use shrubbery
--   functions that require a branch index, such as <a>unifyWithIndex</a>.
--   
--   Note: Types are added to the top of the <tt>front</tt> list as the are
--   encountered, so the list may be reversed from you expected. See the
--   type of <tt>nextZipper</tt>.
data TypeZipper (front :: [Type]) (focus :: Type) (back :: [Type])

-- | Initializes a <a>TypeZipper</a> at the start of the type list
startZipper :: TypeZipper '[] first back

-- | Moves the zipper to the next type in the list. The currently focused
--   item is added to the to the beginning of the <tt>front</tt> list.
moveZipperNext :: TypeZipper front focus (next : back) -> TypeZipper (focus : front) next rest

-- | Builds a <a>BranchIndex</a> for the currently focused type of the
--   zipper. This index can then be used with other functions such as
--   <a>unifyWithIndex</a>.
indexOfFocusedType :: TypeZipper front focus back -> BranchIndex t (ZippedTypes front focus back)


-- | This modules provides functionality similar to Haskell's built-in case
--   statements, but which can be built at run time without losing
--   exhaustivity checking. The technique to satisfy both these desires is
--   to use a type-level list of types to represent the type of value that
--   is available in a given branch, which is analogous to the values you
--   would extract while pattern matching a Haskell type with multiple
--   constructors in a case statement.
--   
--   This is best understood through an example:
--   
--   <pre>
--   intStringOrBoolBranches :: Branches [Int, String, Bool] String
--   intStringOrBoolBranches =
--     branchBuild
--     $ branch doSomethingWithInt
--     $ branch doSomethingWithString
--     $ branch doSomethingWithBool
--     $ branchEnd
--   
--   </pre>
--   
--   Or, if you prefer to use <tt>TypeApplications</tt> to make this more
--   explicit:
--   
--   <pre>
--   intStringOrBoolBranches :: Branches [Int, String, Bool] String
--   intStringOrBoolBranches =
--     branchBuild
--     $ branch <tt>Int    doSomethingWithInt
--     $ branch </tt>String doSomethingWithString
--     $ branch @Bool   doSomethingWithBool
--     $ branchEnd
--   
--   </pre>
--   
--   You can then use the branch values above almost like functions to
--   perform case-like analysis based on the type of value, using
--   <a>selectBranch</a>
--   
--   <pre>
--   &gt;&gt;&gt; selectBranch intStringOrBoolBranches (1 :: Int)
--   doSomethingWithInt 1
--   
--   &gt;&gt;&gt; selectBranch intStringOrBoolBranches ("Foo")
--   doSomethingWithString "Foo"
--   
--   &gt;&gt;&gt; selectBranch intStringOrBoolBranches True
--   doSomethingWithBool True
--   
--   </pre>
module Shrubbery.Branches

-- | From a lexical code perspective you can think of this as "beginning" a
--   branching section (hence the name). It actually finalizes the building
--   of branches to optimized the lookup so that branch dispatching can be
--   done in O(1) time.
branchBuild :: KnownLength paramTypes => BranchBuilder paramTypes result -> Branches paramTypes result

-- | Specifies how to handle a given position in a list of types. The
--   function parameter type is added to the front of the list of types for
--   the branches that are being constructed. This means that the branches
--   must be specified (from "top" to "bottom") in the same order they are
--   given in the list or else you get a compilation error.
branch :: (param -> result) -> BranchBuilder paramTypes result -> BranchBuilder (param : paramTypes) result

-- | Indicates that there are no more branches to specify. This must appear
--   as the final entry in a sequence of <a>branch</a> calls to handle the
--   base case of an empty type list.
branchEnd :: BranchBuilder '[] result

-- | <a>Branches</a> contains an array of functions that have different
--   parameter types, but produce the same result. The <tt>paramTypes</tt>
--   list of types indicates the types of the input parameters, in order.
data Branches (paramTypes :: [Type]) result

-- | <a>BranchBuilder</a> is an efficient interface for building a
--   <a>Branches</a>. Use <a>branchBuild</a> to "execute" the
--   <a>BranchBuilder</a> to make <a>Branches</a>.
data BranchBuilder (paramTypes :: [Type]) result

-- | Selects a function out of some <a>Branches</a> to use for a particular
--   value. This function picks the first function whose parameter type
--   matches, which is usually sufficient as <tt>paramTypes</tt> will
--   usually contain each type only once.
--   
--   If you need to select a particular index, use
--   <a>selectBranchAtProxy</a>.
selectBranch :: (KnownNat branchIndex, branchIndex ~ FirstIndexOf param paramTypes) => Branches paramTypes result -> param -> result

-- | Selects the function out of <a>Branches</a> at the given index so that
--   it can be used with the correct input parameter type.
selectBranchAtIndex :: BranchIndex param paramTypes -> Branches paramTypes result -> param -> result

-- | Selects the function out of <a>Branches</a> at the given index so that
--   it can be used with the correct input parameter type. The index is
--   specified via a proxy value, like such:
--   
--   <pre>
--   selectBranchAtProxy (Proxy :: 1) branches
--   
--   </pre>
--   
--   Or, with type applications:
--   
--   <pre>
--   selectBranchAtProxy @1 Proxy branches
--   
--   </pre>
selectBranchAtProxy :: (KnownNat branchIndex, param ~ TypeAtIndex branchIndex paramTypes) => proxy branchIndex -> Branches paramTypes result -> param -> result


-- | This module provides typeclasses for constructing and deconstructing
--   types that have branches in them. This is to say, sum types or any
--   type that can present a sum-type-like interface.
--   
--   See <a>Union</a> for examples using the provided <a>Union</a> type.
--   Intances of these classes can also be provided for regular Haskell sum
--   types to allow them to be used with the programmable branching
--   provided by <a>Branches</a>, like so:
--   
--   <pre>
--   data MySum = AnInt Int | AString String
--   
--   type instance BranchTypes MySum = [Int, String]
--   
--   instance Dissection MySum where
--     dissect branches sum =
--       case sum of
--         AnInt int -&gt; selectBranch branches int
--         AString string -&gt; selectBranch branches string
--   
--   instance Unification MySum where
--     unifyWithIndex idx =
--       selectBranchAtIndex idx
--         $ branchBuild
--         $ branch AnInt
--         $ branch AString
--         $ branchEnd
--   
--   </pre>
module Shrubbery.Classes

-- | This type family is used by both <a>Dissection</a> and
--   <a>Unification</a> to specify the types of the values available in the
--   branching type. If you provided instances of <a>Dissection</a> or
--   <a>Unification</a>, you'll need to provide an instance of this type
--   family as well.
type family BranchTypes a :: [Type]

-- | A <a>Dissection</a> provides a way to "dissect" a sum type via case
--   analysis. The branches for handling the cases are given via a
--   <a>Branches</a> value.
class Dissection a

-- | Implementations of this must call the appropriate function in the
--   given branches depending on the construction of the value <tt>a</tt>.
--   If 'BranchTypes a' contains duplicate types, the implmentation should
--   be careful to call the correct one in each case.
dissect :: Dissection a => Branches (BranchTypes a) result -> a -> result

-- | A <a>Unification</a> provides a means to construct a sum type by
--   embedding the members of the sum.
class Unification a

-- | Embeds a member of the sum in the sum by specifying its index. This
--   index-based interface is required by implementors to ensure there is
--   not ambiguity when 'BranchTypes a' contains duplicates.
unifyWithIndex :: Unification a => BranchIndex t (BranchTypes a) -> t -> a

-- | Constructs a sum type by embedding a member type within it.
--   
--   This function always embeds the member based on the first time it is
--   found in 'BranchTypes a'. If there are duplicate types in 'BranchTypes
--   a', you should use <a>unifyWithIndex</a> to disambiguate them.
unify :: forall t a branchIndex. (KnownNat branchIndex, branchIndex ~ FirstIndexOf t (BranchTypes a), Unification a) => t -> a

-- | <a>ShowBranches</a> is provided as a convenience for implementing
--   <a>Show</a> on sum types via <a>Dissection</a>
class ShowBranches types
showsPrecBranches :: ShowBranches types => BranchBuilder types (Int -> ShowS)

-- | <a>showsPrecViaDissect</a> can be used as the implementation of
--   <a>showsPrec</a> for types that implement <a>Dissection</a> when all
--   the member types implement <a>Show</a>
showsPrecViaDissect :: (Dissection a, KnownLength (BranchTypes a), ShowBranches (BranchTypes a)) => Int -> a -> ShowS
instance Shrubbery.Classes.ShowBranches '[]
instance (GHC.Show.Show a, Shrubbery.Classes.ShowBranches rest) => Shrubbery.Classes.ShowBranches (a : rest)


-- | This module provides facilities for parsing input values into sum
--   types that implement the <a>Unification</a> type classes. A
--   <a>Parser</a> is constructed by giving a handler for each type in the
--   union that attempts to parse the input value into that type. These
--   handlers must be given in the same order as the types in the type-list
--   that describes the sum type.
--   
--   For instance:
--   
--   <pre>
--   parser :: Parser Maybe String [Int, Bool, String]
--   parser =
--       parseOption (readMaybe :: String -&gt; Maybe Int)
--     $ parseOption (readMaybe :: String -&gt; Maybe Bool)
--     $ parseOption (Just :: Strng -&gt; Maybe String)
--     $ parseEnd
--   
--   </pre>
--   
--   Or, if you prefer to use <tt>TypeApplications</tt>,
--   
--   <pre>
--   parser :: Parser Maybe String [Int, Bool, String]
--   parser =
--       parseOption @Int readMaybe
--     $ parseOption @Bool readMaybe
--     $ parseOption @String Just
--     $ parseEnd
--   
--   </pre>
--   
--   When a <a>Parser</a> is run via <a>parse</a>, it returns the parsing
--   results for all the options, allowing the caller to choose how to
--   handle them. For instance, using the parser above one might write the
--   following code to pick the first successful option from the list:
--   
--   <pre>
--   case catMaybes (parse parser someInputString) of
--     (first:_) -&gt;
--       Just first
--   
--     [] -&gt;
--       Nothing
--   
--   </pre>
module Shrubbery.Parser

-- | A <a>Parser</a> allows an input value to be examined to see whether
--   one or more underlying types can be constructed from it, which are
--   then embedded in a union. The resulting type can be any type that
--   provides an instance of <a>Unification</a>, such as <a>Union</a>.
data Parser f input (types :: [Type])

-- | Executes a <a>Parser</a> with a given input value, producing the list
--   of options returned be each function given to <a>parseOption</a>. The
--   returned list will always have a number of items equal to the number
--   of options added to the <a>Parser</a>.
--   
--   The caller must decide how to choose one or more results from the list
--   of options however is desired.
parse :: (Unification sum, Functor f) => Parser f input (BranchTypes sum) -> input -> [f sum]

-- | Adds an option to the <a>Parser</a>. Every option in the <a>Parser</a>
--   will be given a chance to examine the input and possibly produce a
--   value of the type it produces. IF the option cannot produce a value
--   its type from the input, it should return whatever the appropriate
--   value for functor <tt>f</tt> is. For example, if <a>Maybe</a> is used
--   as <tt>f</tt>, the function would produce <tt>Nothing</tt> when given
--   input it does not want to handle.
--   
--   Any values <tt>a</tt> that are produced by the function will be
--   unified with the other values according the <a>Unification</a> sum
--   type that is expected when <a>parse</a> is used.
parseOption :: forall a f input rest. (input -> f a) -> Parser f input rest -> Parser f input (a : rest)

-- | Represents the base case of where no parsing options are present. You
--   can use this as the second argument to <a>parseOption</a> when have no
--   other options to specify.
parseEnd :: Parser f input '[]


-- | This module provides a implementation of a sum type whose members are
--   known in the type sysem and provides implementations of
--   <a>Dissection</a> and <a>Unification</a>. It can be used as such:
--   
--   <pre>
--   type MyUnion = Union [Int, String]
--   
--   anInt :: MyUnion
--   anInt = unify (0 :: Int)
--   
--   aString :: MyUnion
--   aString = unify "Foo"
--   
--   doSomething :: MyUnion -&gt; String
--   doSomething =
--     dissect
--       $ branchBuild
--       $ branch (show :: Int -&gt; String)
--       $ branch id
--       $ branchEnd
--   
--   </pre>
--   
--   Or you can use type applications:
--   
--   <pre>
--   anInt :: MyUnion
--   anInt = unify @Int 0
--   
--   aString :: MyUnion
--   aString = unify @String "Foo"
--   
--   doSomething :: MyUnion -&gt; String
--   doSomething =
--     dissect
--       $ branchBuild
--       $ branch @Int    show
--       $ branch @String id
--       $ branchEnd
--   
--   </pre>
module Shrubbery.Union

-- | Defines a type whose value can be a value of any one of the specified
--   types.
data Union types

-- | Constructs a union based on the index of a member type in the list.
--   This function can be used rather than <a>unify</a> to disambiguate
--   types that appear multiple times in the list.
--   
--   This is also available as <a>unifyWithIndex</a> from the
--   <a>Unification</a> class.
unifyUnion :: BranchIndex t types -> t -> Union types

-- | Selects a function from the branches based on the value contained
--   within the union. This choice is based entirely on the index specified
--   (or inferred) at the time the union was constructed, so there is no
--   ambiguity if a type appears multiple times in the <a>Union</a>
--   
--   This is also available as the <a>dissect</a> function from the
--   <a>Dissection</a> class.
dissectUnion :: Branches types result -> Union types -> result
instance (Shrubbery.Classes.ShowBranches types, Shrubbery.TypeList.KnownLength types) => GHC.Show.Show (Shrubbery.Union.Union types)
instance Shrubbery.Classes.Dissection (Shrubbery.Union.Union types)
instance Shrubbery.Classes.Unification (Shrubbery.Union.Union types)


-- | <tt>shrubbery</tt> provides programmatic branching constructs based on
--   type-level lists that can be used to write the equivalent of
--   <tt>case</tt> statements when the number and types of cases are not
--   known ahead of time by the programmer.
--   
--   This is useful for writing domain-specific languages that need to do
--   case analysis on sum types supplied by the user, which otherwise
--   requires the user to provide a function to do the case analysis on
--   behalf of the DSL.
--   
--   See <a>Union</a> for a sum type that provides the required braching
--   functionality automatically.
--   
--   See <a>Classes</a> for the typeclass interface that allows types other
--   than those in <a>Union</a> to provide branching functionality.
--   
--   See <a>Branches</a> for the types and functions involved in building
--   and applying the case analysis itself.
module Shrubbery
